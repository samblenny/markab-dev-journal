<!DOCTYPE html><html lang="en"><head><meta charset="utf-8">
<!--
Copyright (c) 2022 Sam Blenny
SPDX-License-Identifier: CC-BY-NC-SA-4.0
-->
<meta name="viewport" content="width=device-width, initial-scale=1">
<meta name="description" content="Dev Journal documenting work on Markab">
<title>2022-04-01: Threaded code + NASM assembly</title>
<link rel="preload" href="../style.css" as="style">
<link href="../style.css" rel="stylesheet"></head><body>
<header><a href="../">Markab Dev Journal</a></header>
<main>
<h1>2022-04-01: Threaded code + NASM assembly</h1>
<hr><ul>
<li><a href="#no-pranks-here">No pranks here</a></li>
<li><a href="#learning-about-threaded-interpreter-models">Learning about threaded interpreter models</a>
<ul>
<li><a href="#summary-of-moving-forth">Summary of Moving Forth</a></li>
<li><a href="#threading-model-mentions-by-jeff-fox">Threading model mentions by Jeff Fox</a></li>
</ul></li>
<li><a href="#assembly-with-nasm">Assembly with NASM</a></li>
</ul><hr>
<h2 id="no-pranks-here">No pranks here</h2>
<p>In the US, it’s traditional to make mischief on this day of this month. But, as
with other unfortunate traditions, I prefer to steer clear. This is just a
normal post.</p>
<h2 id="learning-about-threaded-interpreter-models">Learning about threaded interpreter models</h2>
<p>I’ve been trying to understand the different threaded interpreter models that
have been used to implement Forth systems. The clearest reference, by far, that
I’ve found on the subject is Brad Rodriguez’s <a href="https://www.bradrodriguez.com/papers/moving1.htm">Moving Forth</a> series.</p>
<p>As I understand it, the type of threading you select determines which data
structures you need to use for your dictionary, the algorithm and resulting
efficiency of your inner interpreter, and the complexity of your compiler. It
seems there are typically significant tradeoffs in performance versus
complexity of implementation. That’s important to understand when analyzing old
FIG-Forth implementations because they were designed for ease of portability as
a primary goal, at the expense of performance.</p>
<h3 id="summary-of-moving-forth">Summary of Moving Forth</h3>
<ul>
<li><p><strong>Indirect Threaded Code</strong> (ITC): Used in FIG-Forth and commonly described in
books. Dictionary headers for compiled words contain two pointers, one for
the machine code implementing the word’s action (inner interpreter, literal
loader, etc.), and a second for “parameters” to be used by the machine code
(addresses of headers for words to be called, literal values, etc.). Words
involved in the machine code implementations include <code>ENTER</code>, <code>NEXT</code>, and
<code>EXIT</code>. The downside of ITC is that it requires two layers of pointer
dereferencing to reach the machine code for a word’s action.</p></li>
<li><p><strong>Direct Threaded Code</strong> (DTC): DTC puts the machine code for word’s action
in the dictionary header for that word. So, instead of a pointer to the code,
header holds the actual code, or perhaps a jump instruction to a shared
subroutine. This saves one pointer dereference. Brad Rodriguez prefers this
type of implementation.</p>
<p>There is an important size and speed tradeoff for the <code>NEXT</code> inner
interpreter word at the end of each machine code block. Invoking <code>NEXT</code> with
a <code>JMP</code> can save space, depending on the architecture, but inlining the
machine code for <code>NEXT</code> is likely to be faster. Since <code>NEXT</code> runs frequently,
it has big impact on overall system performance.</p></li>
<li><p><strong>Subroutine Threaded Code</strong> (STC): STC puts a sequence of subroutine calls
in the dictionary header for each word. So, instead of a list of addresses
that get processed by the inner interpreter, the header has machine code with
<code>CALL</code> instructions. Depending on the architecture, STC may perform better
than DTC, based on the number of available registers, speed of <code>PUSH</code> and
<code>POP</code> to return stack, and other factors. Key difference is that STC uses
<code>CALL</code> and <code>RET</code> instead of an the inner interpreter as used by ITC or DTC.
It’s also possible to inline machine code for short words instead of
<code>CALL</code>ing them.</p></li>
</ul>
<h3 id="threading-model-mentions-by-jeff-fox">Threading model mentions by Jeff Fox</h3>
<p>According to Jeff Fox’s <a href="http://www.ultratechnology.com/blog.htm">Ultratechnology blog</a> (scroll down to “10/23/10
Silicon Valley Forth Interest Group Meeting” heading), subroutine threading
with inlined native code is a common implementation method for modern Forth
systems. Also, the <a href="http://www.ultratechnology.com/forth0.htm">Ultratechnology forth0</a> page says that Chuck Moore’s
MachineForth “uses subroutine threading for defined words”.</p>
<h2 id="assembly-with-nasm">Assembly with NASM</h2>
<p>I’ve started experimenting with amd64 (intel64) assembly to try out some of
the ideas I’m reading about with the different threading models.</p>
<p>Initial experiments are at:</p>
<ul>
<li><a href="https://github.com/samblenny/markab-lab/tree/main/asm/amd64" class="uri">https://github.com/samblenny/markab-lab/tree/main/asm/amd64</a></li>
</ul>
<p>Some useful references:</p>
<ul>
<li><p><a href="https://cs.lmu.edu/~ray/notes/nasmtutorial/" class="uri">https://cs.lmu.edu/~ray/notes/nasmtutorial/</a></p></li>
<li><p><a href="https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html" class="uri">https://www.intel.com/content/www/us/en/developer/articles/technical/intel-sdm.html</a>
(programmer reference manuals describing registers, opcodes, etc.)</p></li>
<li><p><a href="https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/" class="uri">https://blog.rchapman.org/posts/Linux_System_Call_Table_for_x86_64/</a>
(good blog post on invoking syscalls on ia64)</p></li>
<li><p><a href="https://github.com/torvalds/linux/blob/v5.10/arch/x86/entry/syscalls/syscall_64.tbl" class="uri">https://github.com/torvalds/linux/blob/v5.10/arch/x86/entry/syscalls/syscall_64.tbl</a>
(“64-bit system call numbers and entry vectors”)</p></li>
<li><p><a href="https://github.com/torvalds/linux/blob/v5.10/arch/x86/include/asm/syscall_wrapper.h" class="uri">https://github.com/torvalds/linux/blob/v5.10/arch/x86/include/asm/syscall_wrapper.h</a>
(explains x64 argument to register mapping for syscalls)</p></li>
<li><p><a href="https://refspecs.linuxbase.org/" class="uri">https://refspecs.linuxbase.org/</a> (ELF and ABI specs)</p></li>
<li><p><a href="https://stackoverflow.com/tags/x86/info" class="uri">https://stackoverflow.com/tags/x86/info</a> (lots of x86/ia64 assembly links)</p></li>
</ul>
</main><footer>
Copyright (c) 2022 Sam Blenny
 — License: <a href="../LICENSE.txt">CC-BY-NC-SA-4.0</a>
</footer></body></html>
